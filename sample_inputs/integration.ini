# This is an example INI input file for the `casino' mode specifying a whole NpT gas-liquid-solid simulation sequence
# for hard spheres. The user is encouraged to read the documentation carefully and run this test file to see how it
# works in practice.
#
# This file contains the general instruction for input files and most information are here. Additional sample input
# file overlap_reduction.ini provides additional information on overlap reduction run type.

########## HOW TO READ THE INSTRUCTION ##########

# Each parameter is described below. For a visual aid, all syntax element (parameters, their values and format) are
# written within double-quotes "...". Each parameter follows its own syntax - it could be for example three numbers
# separated by spaces, which will be denoted as "[number 1] [number 2] [number 3]". Each required parameter token is
# marked by square brackets "[...]" and explained, and the optional tokens are marked with round brackets "(...)".
# Tokens written without any brackets are literals. Each parameter may have multiple variants with a different syntax.
# They are presented using numbered lists "1.", "2.", ... . Some have sub-variants, which are enumerated using
# sub-lists, eg. "4.1.", "4.2.", ...


########## THE GENERAL SECTION ##########

# The file starts with the general section (which is anonymous INI section) specifying common parameters such as the
# molecule's shape, interaction type, etc. as well as the initial configuration, while subsequent sections named
# "\[[run_type].[run_name]\]" (where \[ and \] are literal square brackets) describe runs that will be performed
# sequentially one by one. "[run_type]" should be "integration" for NpT runs and "overlaps" for overlap reduction.
# "[run_name]" is a user-defined name of the run (may be for example "gas", "liquid" and "crystal" as in this exemplary
# input file). The final snapshot of one run is the starting point for the next one. The initial configuration for the
# first run is configured using "initialDimensions", "initialArrangement" and "numOrParticles" parameters in this
# section.

# There is a subset of parameters, which are inherited from a previous run to the next one and can be also specified in
# the general section to be inherited by the first run, namely:
# 1. temperature
# 2. pressure
# 3. moveTypes
# 4. scalingType
# 5. volumeStepSize
# They are denoted as [INHERITABLE PARAMETERS] in their documentation. Each run can override some or all of the
# inherited parameters by explicitly specifying their values. Inheritable parameters are for the convenience sake
# - typically, one keeps for example a constant temperature and only changes the pressure from run to run. Move types
# and scaling type also remain unaltered throughout simulation in most of the cases. However sometimes one may want to
# for example change the scaling type to anisotropic once anisotropic structures emerge - the choice is therefore left
# for the user.

# Below is the full list of general parameters with a detailed description of each.

# The version of RAMPACK this file is targeted to. Input file versions lower than the current RAMPACK version should be
# parsed properly, however some new features will be limited.
# Current version is: 0.2
version = 0.2

# Initial dimensions of the orthorhombic simulation box. Supported variants:
# 1. "[side length]"
#    cubic box with a given side length
# 2. "[x length] [y length] [z length]"
#    explicit box side lengths of a cuboidal cell
# 3. "[1st side x] [... y] [... z] [2nd side x] [... y] [... z] [3rd side x] [... y] [... z]"
#    explicit coordinates of triclinic box vectors
# 4. "auto"
#    box size will be calculated automatically based on cell size from "initialArrangement"
initialDimensions = 100 100 100

# Initial arrangement. It is generated first by creating a lattice of a specific type, then some lattice transformations
# may be applied. At the end, a way of choosing unoccupied spots (if a number of particles is smaller than the number of
# slots available) may be given. General syntax:
#
# "[cell specification]" | "[transformation 1]" | ... | "[transformation n]" | "[population scheme]"
#
# Optional transformations can be stacked together and are separated using a pipe "|". Population scheme is also
# optional (implicit behaviour is equivalent to "populate serial xyz" - see below).
#
# "[cell specification]" specifies the type of a unit cell and a number of those cells. Variants:
# 1. "[cell specification]" := "[cell type] default"
#    create n x n x n (where n is chosen automatically) lattice just large enough to accommodate all particles.
#    "initialDimensions" cannot be "auto" in this variant - cell dimensions are inferred from the box size.
# 2. "[cell specification]" := "[cell type] ncell [nx] [ny] [nz]"
#    number of cells is specified explicitly. Cell dimensions are calculated based on the box size (thus is cannot be
#    "auto" in this case)
# 3. "[cell specification]" := "[cell type] ncell [nx] [ny] [nz] dim [cell dim]"
#    both number of cells ("[nx] [ny] [nz]") and cell dimensions ("[cell dim]") are specified explicitly. Box dimensions
#    have to be "auto" - they are calculated based on lattice dimensions. "[cell dim]" can be:
#    3.1 "[cell dim]" := "[linear size]"
#    3.2 "[cell dim]" := "[x length] [y length] [z length]"
#    3.3 "[cell dim]" := "[1st side x] [... y] [... z] [2nd side x] [... y] [... z] [3rd side x] [... y] [... z]"
#    Variants 3.2 and 3.3 have identical meaning as variants 2. and 3. of "initialDimensions". Variant 3.1 is more
#    subtle and depends on "[cell type]" (see below). For cubic types "sc", "bcc", "fcc" and "custom" type the cell is
#    then cubic and "[linear size]" is the side length of the cube. For hexagonal types "hcp", "hexagonal" this variant
#    DOES NOT produce a cubic cell, but a cuboidal one with such dimensions that spheres with appropriate radius placed
#    in this cell would be tangent (which would not be possible in a cubic cell). The specific dimensions are described
#    below in "[cell type]" specification.
#
# "[cell type]" specifies how many molecules are in the cell and where they are placed. Note that it does not force
# the shape of the cell, but only the number and placement of molecules withing the cell (the shape is controlled by the
# "ncell" and "dim" arguments from "[cell specification]" as well as simulation box dimensions - see above). Supported
# variants:
# 1. "sc"
#    Simple cubic (a single particle in the middle)
# 2. "bcc"
#    Body centred cubic (positions relative to cell: {0.25, 0.25, 0.25}, {0.75, 0.75, 0.75})
# 3. "fcc"
#    Face centred cubic (positions relative to cell: {0.25, 0.25, 0.25}, {0.25, 0.75, 0.75}, {0.75, 0.25, 0.75},
#    {0.75, 0.75, 0.25})
# 4. "hcp axis [ax]"
#    Hexagonal close packed. "[ax]" specifies orientation of the cell - it is the direction orthogonal to hexagonal
#    honeycombs. Relative positions for "[ax]" = "z" are: {1/4, 1/12, 1/4}, {3/4, 7/12, 1/4}, {1/4, 5/12, 3/4},
#    {3/4, 11/12, 3/4}. Variant 3.1 of "[cell dim]" specifying linear size L (for "[ax]" = "z") produces cuboidal cell
#    of size {L, sqrt(3)*L, 2*sqrt(6)*L/3}. For "[ax]" = "x", "y" everything is permuted cyclically.
# 5. "hexagonal axis [ax]"
#    Hexagonal cell. "[ax]" specifies orientation of the cell - it is the direction orthogonal to hexagonal honeycombs,
#    stacked along it (without any alternation as for hcp lattice). Relative positions for "[ax]" = "z" are:
#    {1/4, 1/4, 1/2}, {3/4, 3/4, 1/2}. Variant 3.1 of "[cell dim]" specifying linear size L (for "[ax]" = "z") produces
#    cuboidal cell of size {L, sqrt(3)*L, L}. For "[ax]" = "x", "y" everything is permuted cyclically.
# 6. "custom shapes [shape 1] , ... , [shape n]"
#    Custom unit cell with arbitrary shape positions and orientation. Shapes are separated using commas ",".
#    "[shape]" has 2 variants:
#    6.1. "[shape]" := "[pos x] [pos y] [pos z]"
#         Specifies default-oriented shape with a given position as relative coordinates within the cell (in the range
#         [0, 1))
#    6.2. "[shape]" := "[pos x] [pos y] [pos z] [rot x] [rot y] [rot z]"
#         Specifies a shape with a given position as relative coordinates within the cell (in the range [0, 1)) and with
#         orientation specified by angles of rotations (in degrees) around z, y and x axes (in this order)
#
# All keywords in "[cell specification]": "ncell", "dim", "default", "axis", "shapes" may appear in an arbitrary order
# (possibly different then the one presented in the specification). For example "hcp axis x ncell 5 10 15 dim 2" is the
# same as "hcp dim 2 ncell 5 10 15 axis x".
#
# "[transformation]" specifies an optional transformation of a lattice (which can be stacked together). Available
# transformations:
# 1. "optimizeCell [spacing] [axis order]"
#    Optimization of cell dimensions. It maximally shrinks the lattice (axis by axis, in an order given by
#    "[axis order]") without introducing overlaps in directions of lattice vectors (so that the angles remain
#    unchanged). Afterwards, it expands the lattice by "[spacing]" in the directions of CELL HEIGHTS (not lattice
#    vectors, however the two are the same for cubic/cuboidal cells), also preserving the angles.
# 2. "optimizeLayers [spacing] [layer axis]"
#    Optimization of the distances between particles and cell dimensions in a direction given by "[layer axis]", in a
#    layer-wise fashion. First, it identifies layers and makes them tangent (first making 1st and 2nd layer tangent,
#    then 2nd and 3rd, etc). Then, it optimizes cell dimension so that layers of adjacent cells are tangent. Afterwards,
#    it introduces a spacing "[spacing]" between all layers in the directions of CELL HEIGHTS (not lattice vectors,
#    however the two are the same for cubic/cuboidal cells). Box angles are preserved in the whole procedure.
# 3. "columnar [column axis] [rng seed]"
#    Creates a columnar phase from the lattice - it identifies columns along axis "[column axis]" (using relative cell
#    coordinates) and translates them by a random amount in columns' direction (along a lattice vector). "[rng seed]"
#    specifies a seed of a random number generator used to sample random translations. Works only for periodic lattices.
# 4. "randomizeFlip [rnd seed]"
#    With a probability 1/2, it rotates each molecule by 180 degrees around a secondary axis placed in a geometric
#    origin. Therefore, on average, half of the particles will be "flipped".
# 5. "layerRotate [layer axis] [rot. axis] [rot. angle] (alternating)"
#    It identifies layers in the lattice in "[layer axis]" direction and rotates particles by "[rot. angle]" degrees
#    around "[rot. axis]" axis. If "alternating" is specified, molecules within even layers will be rotated
#    counter-clockwise and in odd layers - clockwise. If only one layer is identified within a unit cell (for example in
#    a sc lattice), 2 unit cells will be joined (the same is true for any odd number of layers in a unit cell). Works
#    only for periodic lattices. If "alternating" is not specified, all molecules are rotated by a same angle,
#    counter-clockwise.
#
# "[population scheme]" describes how lattice should be filled with particles (if their number is smaller than the
# number of slots in the lattice). Variants:
# 1. "[population scheme]" := "populate serial ([axis order])"
#    Populates the lattice cell by cell looping through cell indices. The order of loops is given, from outermost to
#    innermost, by "[axis order]". For example, for "[axis order]" = "yxz", first z column is filled, then zx plane is
#    filled with those columns, and lastly those planes are stacked in y direction. Within a cell, molecules are placed
#    in the order in which they appear within the cell. Default values of "[axis order]" is "xyz".
# 2. "[population scheme]" := "random [rng seed]"
#    Molecules are placed at random using RNG sequence seeded with "[rng seed]". However, their order is not completely
#    random - particles with close indices will have relatively close real-space positions (for a better cache
#    performance).
#
# Here are a few of examples of initial configurations which can be created:
# 1. "initialDimensions = 10"
#    "initialArrangement = sc default"
#    "numOfParticles = 1000"
#    Create a simple cubic lattice of 10 x 10 x 10 cells, where the cells are cubes of size 1 x 1 x 1
# 2. "initialDimensions = 100"
#    "initialArrangement = sc ncell 5 10 20 | optimizeCell 0.1 xyz | populate random"
#    "numOfParticles = 500"
#    Create a simple cubic lattice of 5 x 10 x 20 cells, optimize particle distance to 0.1 in each direction and then
#    populate half of slots with molecules at random.
# 3. "initialDimensions = auto"
#    "initialArrangement = hcp ncell 2 10 10 dim 10 | layerRotate x y 30 alternating | optimizeCell 0.1 yzx"
#    Create a hcp lattice, perform alternating rotation around y axis by 30 degrees, of layers along x axis (there are
#    2 hcp cells in this direction, so 4 layers altogether) and then shrink the cell size first optimizing distances
#    within the layers and then the distances between the layers. The resulting structure is anticlinic crystal I
#    (hexagonal order within a layer and alternating layer tilt)
# 4. "initialDimensions = auto"
#    "initialArrangement = hexagonal ncell 4 10 10 dim 10 | optimizeCell 0.1 yzx | columnar x 1234 | randomizeFlip 1234"
#    Creates hexagonal lattice, optimizes cell size, makes the cell columnar along x axis and randomizes flips. All RNG
#    seeds were equal 1234. The resulting phase is Col_h phase along x axis with random flips.
#
# "preview" program mode may be very useful when programming the initial arrangement - it enables one to see the
# preview of the initial configuration before starting the simulation. For more information see
# "./rampack preview --help".
initialArrangement = sc default

# If specified, walls will be created on both opposite box faces intersected by specified axes. For example, using
# "xy" in a cubic box with side length L creates walls described by equations: x=0, x=L, y=0 and y=L. Leaving the field
# empty or skipping it leaves the simulation box without any walls. Please note that placing a wall does not turn off
# the scaling in this direction. If one intends so, it has to be done manually when specifying "scalingType" (see
# below).
walls =

# The number of molecules to be simulated
numOfParticles = 1000

# [INHERITABLE PARAMETER]
#
# Temperature in k_B units. The temperature can be just a floating-point constant, or a dynamic parameter, which changes
# based on a current simulation cycles. Available dynamic parameters:
# 1. const [value]
#    A constant parameter, which always has the same value. It is exactly the same as just passing a single number.
# 2. linear [initial value] [slope]
#    If current cycle is "[current cycle]", the value is calculated as "[initial value]" + "[slope]" * "[current cycle]"
# 3. exp [initial value] [rate]
#    If current cycle is "[current cycle]", the value is calculated as
#    [initial value]" * exp("[rate]" * "[current cycle]")
# 4. piecewise [cycle 1] [parameter 1] , [cycle 2] [parameter 2] , ...
#    A piecewise combination of dynamic parameters. The parameters are separated by commas. First, the number of cycle
#    "[cycle ...]" is given when the specific parameter should start, and then parameter specification
#    "[parameter ...]", (as in 1. - 3.). "[cycle 1]" has to be equal 0 and subsequent "[cycle ...]"-s should be in an
#    ascending order. Constituent parameters are shifted so that they always start from 0. As an example:
#       "piecewise 0 const 10 , 1000 linear 10 0.01 , 2000 20"
#    There, in cycles 0-999 temperature is constant and equal 10, then in cycles 1000-1999 it grows linearly to 20
#    (to be precise, at cycle 1999 it is 19.99), and then it becomes 20 in 2000-th cycle and stays as such indefinitely.
#    Note, that for the 3-rd parameter a single value "20" was used equivalently to "const 20".
# It is important to note that last change of the temperature happens after the last thermalisation cycle and is frozen
# in the averaging stage. It is advisable to use a constant temperature for some number of cycles in the last part of
# the thermalization stage.
#
# Please note, that all non-constant dynamic parameters base their values only on the cycle number - it means that when
# a dynamic parameter is inherited by the next run, it will go back to the initial value, since the next run starts from
# 0 cycles.
#
# In this exemplary input file, "temperature" in the general section will be inherited by subsequent runs.
temperature = 1

# [INHERITABLE PARAMETER]
#
# Pressure. It can be a floating-point constant or a dynamic parameter (see "temperature" for reference).
#
# In this exemplary input file, we do not specify the pressure in the general section - it will be run-specific. It can
# be left empty or omitted altogether.
pressure =

# [INHERITABLE PARAMETER]
#
# Comma-separated list of molecule move types that should be performed during the run. Given the number of molecules in
# the system, each move type declares how many moves should be performed. Move type is sampled at random so that during
# each cycles the average number of moves of a given type matches the declaration. Most move types support dynamic
# changes of step sizes to reach target acceptance rate. Supported move type are as follows:
# 1. "translation [initial step size] ([max step size])"
#    Performs a translation for a randomly selected molecule. Each translation coordinate is independently selected
#    from a uniform interval [-"[step size]", "[step size]"] ("[step size]" is initialized from "[initial step size]").
#    If specified, "[step size]" is capped from above by "[max step size]". In a single cycle each particle is perturbed
#    on average once.
# 2. "rotation [initial angle]"
#    Performs a rotation of a randomly selected molecule. Rotation is done around a random axis by an angle sampled
#    uniformly from an interval [-"[angle]", "[angle]"] ("[angle]" is initialized from "[initial angle]"). In a single
#    cycle each particle is perturbed on average once.
# 3. "rototranlslation [initial step size] ([initial angle] ([max step size]))"
#    Performs simultaneous translation and rotation of a randomly selected molecule. The way of sampling and parameter
#    names are the same as for "translation" and "rotation" moves. Both: translation and rotation step sizes are always
#    adjusted simultaneously by the same factor, so they ratio stays constant. If "[initial angle]" is omitted, its
#    optimal value is estimated automatically using heuristic formula (it is optimized for elongated molecules - for
#    small anisotropies it may be too large).
# 4. "flip ([flip every])"
#    Performs a rotation by 180 degrees of a random particle around its secondary axis. During one cycle
#    1 / "[flip every]" fraction of particles is flipped (if not specified, "[flip every]" defaults to 10).
#
# In this exemplary input file, "moveTypes" in the general section will be inherited by subsequent runs.
moveTypes = translation 10

# [INHERITABLE PARAMETER]
#
# Type of the scaling. Notice that some types allow independent moves for some or all sides which facilitate relaxation
# of the diagonal part of stress tensor (directional pressures) or even full triclinic relaxation of sheer pressure.
# If "scalingType" is variant 1.-3. and the box is triclinic, scaling is performed height-wise, ie. face angles remain
# unaltered. Alternatives for "scalingType":
# 1. "delta V"
#    The ratio of all box heights remains constant while the volume is changed by an amount sampled from
#    [-"volumeStepSize", "volumeStepSize"] interval uniformly
#
# 2. "(independent) [scaling distribution] [direction specification]"
#    Generalized scaling, where one can customize type of the scaling, which directions should be scaled, which should
#    be coupled, whether scaling is performed in one direction per move or all together, etc.
#
#    "[scaling distribution]" can be one of:
#    2.1.1. "linear"
#           Linear scaling is achieved by sampling uniformly a random number from [-"volumeStepSize", "volumeStepSize"]
#           interval and changing appropriate box heights by this amount.
#    2.1.2. "log"
#           Logarithmic scaling is achieved by sampling uniformly a random number "w" from
#           [-"volumeStepSize", "volumeStepSize"] interval and multiplying appropriate box heights by a factor exp(w).
#
#    "[direction specification]" describes direction ("x", "y" and "z") in which scaling should be performed in
#    accordance to "[scaling distribution]". By default, all directions are uncoupled, so using "xyz" gives fully
#    anisotropic scaling where all directions are scaled independently. Coupling is achieved by surrounding coupled
#    directions by parentheses "(...)". For example "(zx)y" makes "y" independent direction, while "x" and "z" are
#    scaled together. One or more directions can be blocked by surrounding them with square brackets "[...]". For
#    example "xy[z]" specifies uncoupled scaling of "x" and "y" directions and "z" remains unaltered. Please note that
#    the behaviour of all directions has to be given explicitly, thus, for example "(xy)" is malformed, since "z" is
#    missing. Apart from generalized syntax with "x", "y", "z", "(...)" and "[...]", a few expressive shortcuts are
#    available:
#    2.2.1. "isotropic"        => equivalent to "(xyz)"
#    2.2.2. "anisotropic x"    => equivalent to "x(yz)"
#    2.2.3. "anisotropic y"    => equivalent to "y(zx)"
#    2.2.4. "anisotropic z"    => equivalent to "z(xy)"
#    2.2.5. "anisotropic xyz"  => equivalent to "xyz"
#
#    "independent" is an optional switch. By default, scaling is performed in all directions at once. For example, for
#    "(xy)z" one scaling factor is sampled for "x" and "y" directions and a different, independent one is sampled for
#    "z" direction, however scaling in all directions is performed at once. If "independent" is included, only one
#    uncoupled direction is selected at random during volume move. Staying with "(xy)z" example, either both "x" and "y"
#    will be scaled in a coupled manner and "z" unscaled, or "x" and "y" unaltered, and "z" scaled.
#
# 3. "(independent) delta triclinic"
#    Box side vectors are translated by random vectors with coordinates sampled uniformly from
#    [-"volumeStepSize", "volumeStepSize"] interval. This scaling types enables to perform simulations in
#    isobaric-isotension ensemble (relaxing off-diagonal parts of stress tensor). If "independent" is specified, only a
#    single, randomly sample side will be perturbed. Otherwise, all are perturbed at once.
#
# In this exemplary input file, "scalingType" in the general section will be inherited by subsequent runs, apart from
# the last run "[run.solid]", for which we will choose triclinic delta scaling to facilitate full relaxation of the
# crystalline structure.
scalingType = delta V

# [INHERITABLE PARAMETER]
#
# The maximal size of the volume move. Its meaning is dependent on scaling type. Please refer to "scalingType" above.
#
# In this exemplary input file, "volumeStepSize" in the general section will be inherited by subsequent runs.
volumeStepSize = 1000

# The seed for random number generator
seed = 1234

# The shape of the molecule. It is specified by "shapeName", while its (shape-dependent) parameters, such as eg. the
# axis ratio are given by "shapeAttributes". Each shape may support one ore more interaction types, specified by
# "interaction". A full list of shapes, together with their attributes and interactions is given below. Each shape
# declares a set of the so-called named points, which are some features, like origins of constituent subshapes, ect. By
# default, each shape defines one named point - "o" for geometric origin. Non-standard, if present, one are described
# for each shape individually. In particular, shapes may of may not declare mass centre "cm" named point.
#
# Program mode "shape-preview" may be useful when selecting shape parameters - it displays rich metadata and enables one
# to generate Wolfram Mathematica preview of the shape. See "./rampack shape-preview --help" for more info.
#
# 1. "shapeName = Sphere"
#    "shapeAttributes = [radius]"
#    "interaction = [interaction]"
#    sphere with a radius "[radius]". Supported interaction types:
#    1.1. "hard"
#         hard-core interaction
#    1.2. "lj [epsilon] [sigma]"
#         Lennard-Jones interaction with a standard definition of "[epsilon]" and "[sigma]" parameters:
#         LJ(r) = 4 epsilon ((sigma/r)^12 - (sigma/r)^6)
#         r is the distance between interaction centers
#    1.3. "repulsive_lj [epsilon] [sigma]"
#         Lennard-Jones, but only the repulsive part - the so-called Weeks-Chandler-Anderson potential:
#         LJ(r) + epsilon   for r < 2^(1/6),
#         0                 for r >= 2^(1/6).
#    1.4. "square_inverse_core [epsilon] [sigma]"
#         short-ranged attractive or repulsive interaction, resembling screened dipolar interaction, defined as:
#         epsilon ((sigma/r)^2 - 1)   for r < sigma,
#         0                           for r >= sigma.
#    It defines additional named point "cm" for mass centre.
#
# 2. "shapeName = Spherocylinder"
#    "shapeAttributes = [length] [radius]"
#    "interaction = hard"
#    spherocylinder with cap radius "[radius]" (or, equivalently, half-width) and the distance between cap centers
#    "[length]". For the default orientation, "Spherocylinder" is aligned with z axis. Only hard interaction is
#    supported. It defines two additional named points: "beg" and "end" for origins of caps of the spherocylinder as
#    well as"cm" for mass centre.
#
# 3. "shapeName = KMer"
#    "shapeAttributes = [number of spheres] [radius] [distance]"
#    "interaction = [interaction; the same ones as for Sphere]"
#    a linear chain of "[number of spheres]" spheres with radius "[radius]" lying on z axis. The centers are equally
#    spaced with a distance "[distance]". Supported interactions: same as for "Sphere", however each pair of beads is
#    treated separately. It defines some additional named points. First group is inherited from "Polysphere". Second
#    group is KMer-specific: "beg" and "end" for the first and the last sphere's origin as well as "cm" for mass centre.
#
# 4. "shapeName = PolysphereBanana"
#    "shapeAttributes = [arc radius] [arc angle] [number of spheres] [sphere radius]"
#    "interaction = [interaction; the same ones as for Sphere]"
#    chain of "[number of spheres]" spheres with radius "[sphere radius]" placed on an arc (banana-shaped). The arc is
#    defined by its radius "[arc radius]" and arc angle "[arc angle]". The centres of spheres are equidistantly placed
#    on the arc and its endpoints are at the same time the centres of outermost spheres. The centers of spheres in
#    "PolysphereBanana" molecule with a default orientation lie within xz plane, the main axis (joining the ends of the
#    arc) is z axis and the arc is bent towards the negative x semi-axis (the vector joining either endpoint and the
#    middle has a negative x component). For "[arc angle]" < pi, the origin is in the middle of the segment joining
#    endpoints, while for "[arc angle]" >= pi it coincides with the arc origin (in order to minimize circumsphere
#    radius). Supported interactions: same as for "Sphere", however each pair of beads is treated separately. It defines
#    some additional named points. First group are ones inherited from Polysphere, namely "s[x]", where "[x]" is an
#    index of a single sphere (starting from 0) describing their origins. Second group is PolysphereBanana-specific:
#    "beg" and "end" for the first and the last sphere's origin. It also defines mass centre "cm" named point if spheres
#    don't overlap.
#
# 5. "shapeName = PolysphereLollipop"
#    "shapeAttributes = [num of spheres] [small radius] [large radius] [small penetration] [large penetration]"
#    "interaction = [interaction; the same ones as for Sphere]"
#    linear chain of "[num of spheres]" spheres placed on the z axis, where a single sphere at the end has different
#    size than the rest of them (usually larger). "[small radius]" and "[large radius]" are radii of, respectively, all
#    apart from the last, and the last sphere. Similarly, "[small penetration]" and "[large penetration]" describe how
#    much spheres overlap. In particular, 0 means that the spheres are tangent. The origin is chosen in such a way that
#    the circumsphere radius is minimal. Supported interactions: same as for "Sphere", however each pair of beads is
#    treated separately. It defines some additional named points. First group are ones inherited from Polysphere, namely
#    "s[x]", where "[x]" is an index of a single sphere (starting from 0) describing their origins. Second group is
#    PolysphereLollipop-specific: "ss" and "sl" for origins of, respectively, the first small sphere at the beginning
#    and the large sphere. It also defines mass centre "cm" named point if both "[small penetration]" and
#    "[large penetration]" are zero.
#
# 6. "shapeName = PolysphereWedge"
#    "shapeAttributes = [num of spheres] [bottom radius] [top radius] [penetration]"
#    "interaction = [interaction; the same ones as for Sphere]"
#    linear chain of "[num of spheres]" spheres placed on the z axis, where radii of spheres are increased linearly.
#    "[bottom radius]" and "[top radius]" are radii of, respectively, the bottom and the top sphere. "[penetration]"
#    describes how much spheres overlap. In particular, 0 means that the spheres are tangent. The origin is chosen in
#    such a way that the circumsphere radius is minimal. Supported interactions: same as for "Sphere", however each pair
#    of beads is treated separately. It defines some additional named points. First group are ones inherited from
#    Polysphere, namely "s[x]", where "[x]" is an index of a single sphere (starting from 0) describing their origins.
#    Second group is PolysphereWedge-specific: "beg" and "end" for origins of, respectively, the bottom sphere and the
#    top one. It also defines mass centre "cm" named point if "[penetration]" is zero.
#
# 7. "shapeName = PolyspherocylinderBanana"
#    "shapeAttributes = [arc radius] [arc angle] [number of segments] [radius] ([subdivisions])"
#    "interaction = hard"
#    a molecule similarly shaped as "PolysphereBanana", but using spherocylinders. "[arc radius]" and "[arc angle]" have
#    identical meaning as in "PolysphereBanana", "[radius]" is the radius of spherocylinders' caps (equivalently their
#    half-width). "[number of segments]" is a number of spherocylinders used to approximate the arc - the arc is divided
#    into that many segments and spherocylinders are placed around them. The default orientation is analogous to
#    "PolysphereBanana". If the optional parameter "[subdivisions]" is specified, each spherocylinder is divided into
#    that many parts - it does not change the physics, but may increase the speed of the simulation. Default value is 1
#    (no divisions). Only hard interaction is supported. It defines some additional named points. First group are ones
#    inherited from Polyspherocylinder (see 11.). Second group is PolyspherocylinderBanana-specific: "beg" is the origin
#    of the first cap at the beginning of the banana, and "end", similarly, for the last cap.
#
# 8. "shapeName = SmoothWedge"
#    "shapeAttributes = [length] [bottom radius] [top radius] ([subdivisions = 1])"
#    "interaction = hard"
#    a shape similar to PolysphereWedge, but smooth. It is built by placing 2 spheres with radii "[bottom radius]" (R)
#    and "[top radius]" (r) with centers distant by "[length]" (l) and computing a convex hull of them. Spheres are
#    placed on z axis, one at the bottom and the other at the top with z coordinates, respectively, (R - r - l)/2 and
#    (R - r + l)/2. This way the circumsphere is optimal. One can optionally specify number of subdivisions:
#    "[subdivisons]" to use the neighbour grid more efficiently. Only hard interaction is supported. It defines two
#    non-standard named points: "beg" and "end" for the origins of, respectively, the bottom sphere and the top one.
#
# 9. "shapeName = GenericXenoCollide"
#    "shapeAttributes = primaryAxis [...] secondaryAxis [...] geometricOrigin [...] volume [...] script [...]
#                       (namedPoints [...])"
#    "interaction = hard"
#    a general hard convex shape with collision detection performed using XenoCollide algorithm. Shape attributes are
#    in the format "[attribute name] [attribute value]" (ex. "volume 2.5") - their order is arbitrary, but all required
#    attributes have to be specified (all but optional "namedPoints").
#    9.1. "primaryAxis [x] [y] [z]"
#         specifies the primary molecular axis used for example in P2 order parameter. "[x]", "[y]", "[z]" are vector
#         coordinates of the axis (is is normalized automatically)
#    9.2. "secondaryAxis [x] [y] [z]"
#         specifies the secondary molecular axis used for example in flip moves. "[x]", "[y]", "[z]" are vector
#         coordinates of the axis (is is normalized automatically)
#    9.3. "geometricOrigin [x] [y] [z]"
#         specifies the geometric origin, used for example in flip moves. "[x]", "[y]", "[z]" are its coordinates
#    9.4. "volume [volume value]"
#         specifies the volume of the shape; unfortunately there is no automatic method to calculate the volume exactly
#    9.5. "script [&-separated commands]"
#         defines the shape. It is done by 3 types of operations: 1. creating primitive shapes, 2. moving and rotating
#         them, 3. combining them using Minkowski sum, Minkowski difference or convex hull. Primitive shapes are created
#         on the stack. Moving and rotating operations transform last shape in the stack, and operations combine two
#         last shapes on the stack. Please note, that moving and rotating is visible only when shapes are combined.
#         For a single shape and moves and rotations are ignored.
#         Available primitive shapes:
#         9.5.1.  "cuboid [x side length] [y side length] [z side length]"
#                 places an axis-oriented cuboid with side lengths "[... side length]" with its center at {0, 0, 0}
#         9.5.2.  "disk [radius]"
#                 places a disk with radius "[radius]" with its center at {0, 0, 0} on XY plane
#         9.5.3.  "ellipse [x semi-axis length] [y semi-axis length]"
#                 places an axis-oriented ellipse with semi-axes lengths "[... semi-axis length]" with its center at
#                 {0, 0, 0} on XY plane
#         9.5.4.  "ellipsoid [x semi-axis length] [y semi-axis length] [z semi-axis length]"
#                 places an axis-oriented ellipsoid with semi-axes lengths "[... semi-axis length]" with its center at
#                 {0, 0, 0}
#         9.5.5.  "football [length] [radius]"
#                 places a rugby-ball shaped solid. It is constructed by taking three points (l = "[length]",
#                 r = "[radius]"): {-l/2, 0, 0}, {l/2, 0, 0}, {0, r, 0}, joining them using circle fragment and
#                 revolving it around x axis
#         9.5.6.  "point [x] [y] [z]"
#                 places a singular point at "[x] [y] [z]" coordinates
#         9.5.7.  "rectangle [x side length] [y side length]"
#                 places an axis-oriented rectangle with side lengths "[... side length]" with its center at {0, 0, 0}
#                 on XY plane
#         9.5.8.  "saucer [radius] [thickness]"
#                 places a saucer shaped solid. It is constructed by taking three points (t = "[thickness]",
#                 r = "[radius]"): {0, 0, -r}, {0, 0, r}, {t/2, 0, 0}, joining them using circle fragment and
#                 revolving it around x axis, resulting in a spherical cap. It is then joined with another cap, which
#                 is mirrored through YZ plane, creating a solid shape
#         9.5.9.  "segment [length]"
#                 places a segment between points (l = "[length]"): {-l/2, 0, 0} and {l/2, 0, 0}
#         9.5.10. "sphere [radius]"
#                 places a sphere with radius "[radius]" with its center at {0, 0, 0}
#         Moving and rotation operations:
#         9.5.11. "move [x] [y] [z]"
#                 translates the last shape on the stack by a vector "[x] [y] [z]"
#         9.5.12. "rotate [x angle] [y angle] [z angle]"
#                 rotates the last shape on the stack around its origin by subsequent counterclockwise rotations:
#                 1. around x axis by "[x angle]" angle, 2. around y axis by "[y angle]" angle, 3. around z axis by
#                 "[z angle]" angle. All angles are in degrees.
#         Combining operations:
#         9.5.13. "sum"
#                 replaces last two shapes on the stack with their Minkowski sum
#         9.5.14. "diff"
#                 replaces last two shapes on the stack with their Minkowski different ("before last" minus "last")
#         9.5.13. "wrap"
#                 replaces last two shapes on the stack with their convex hull
#         As an example: the shape "SmoothWedge" with attributes "5 2 1" can be recreated by:
#         "script sphere 2 & move 0 0 -2 & sphere 1 & move 0 0 3 & wrap"
#    9.6. "namePoints [point name 1] [x1] [y1] [z1] [point name 2] [x2] [y2] [z2] ..."
#         specifies additional named points (optional attribute). For each point, first the name (without spaces!) is
#         given "[point name i]", then its subsequent coordinates "[xi] [yi] [zi]". For example, to mimic the ones from
#         "SmoothWedge" with attributes "5 2 1", one should use: "namedPoints sl 0 0 -2 ss 0 0 3"
#    Only hard interaction is supported.
#
# 10. "shapeName = Polysphere"
#     "shapeAttributes = primaryAxis [...] secondaryAxis [...] geometricOrigin [...] volume [...] spheres [...]
#                        (namedPoints [...])"
#     "interaction = [interaction; the same ones as for Sphere]"
#     a general hard convex shape built from arbitrary set of spheres. Shape attributes are in the format
#     "[attribute name] [attribute value]" (ex. "volume 2.5") - their order is arbitrary, but all required attributes
#     have to be specified (all but optional "namedPoints"). Attributes "primaryAxis", "secondaryAxis",
#     "geometricOrigin", "volume", "namedPoints" are the same as for "GenericXenoCollide" (see 9.1.-9.4, 9.6.).
#     "[spheres]" defines the radii and positions of spheres:
#     "[spehres]" := "[sphere specification 1] [sphere specification 2] ..."
#     "[sphere specification i]" := "[r i] [x i] [y i] [z i]"
#     where "[r i]" is radius of i-th sphere and "[x i] [y i] [z i]" coordinates of its center. "Polysphere", apart
#     from custom named points, defines by default named points "s[x]", where "[x]" is an index of a single sphere
#     (starting from 0) describing their origins. Supported interactions: same as for "Sphere", however each pair of
#     beads is treated separately.
#
# 11. "shapeName = Polyspherocylinder"
#     "shapeAttributes = primaryAxis [...] secondaryAxis [...] geometricOrigin [...] volume [...] spheres [...]
#                        {spherocylinders [...]|chain [...]} (namedPoints [...])"
#     "interaction = hard"
#     a general hard convex shape built from arbitrary set of spherocylinders. Shape attributes are in the format
#     "[attribute name] [attribute value]" (ex. "volume 2.5") - their order is arbitrary, but all required attributes
#     have to be specified ("primaryAxis", "secondaryAxis", "geometricOrigin", "volume" and at least one of:
#     "spherocylinders", "chain"; "namedPoints" is optional). Attributes "primaryAxis", "secondaryAxis",
#     "geometricOrigin", "volume", "namedPoints" are the same as for "GenericXenoCollide" (see 9.1.-9.4, 9.6.).
#     Spherocylinders are defined by either of: "spherocylinders", "chain" or combination of both.
#     11.1. "[chain]" := "[chain radius] [x1] [y1] [z1] [x2] [y2] [z2] ..."
#           Creates a chain of spherocylinders with radius "[chain radius]" joining points i = 1, 2, ..., whose
#           coordinates are "[x i] [y i] [z i]".
#     11.2. "[spherocylinders]" := "[spherocylinder specification 1] [spherocylinder specification 2] ..."
#           "[spherocylinder specification i]" := "[r i] [beg x i] [beg y i] [beg z i] [end x i] [end y i] [end z i]"
#           Creates a set of independent, not necessarily connected spherocylinders. i-th spherocylinder is specified
#           by its radius "[r i]", position of first cap center "[beg x i] [beg y i] [beg z i]" and position of second
#           cap center "[end x i] [end y i] [end z i]"
#     "Polyspherocylinder", apart from custom named points, defines by default named points "o[x]", "b[x]", and "e[x]",
#     where "[x]" is an index of a single spherocylinder (starting from 0) and "o", "b" and "e" stand for its,
#     respectively, origin, first cap's center and last cap's center. Only hard interaction is supported.
shapeName = Sphere
shapeAttributes = 0.5
interaction = hard

# Number of parallel threads used to perform volume moves
scalingThreads = 4

# The parallelization of molecule moves is done using the domain division - the space is divided into cuboidal subspaces
# with inactive (ghost) layers between them. This parameter specifies how many divisions should be made in each
# direction. Each domain is then assigned to a separate thread. As a result, the number of threads is the product of the
# number of divisions in each direction. Format:
# "[number of divisions in x direction] [... y ...] [... z ...]"
# Optimally one should use the same number of threads for both volume and molecule moves. A lower number of scaling
# threads than molecule threads is forbidden. Then "1 1 1" is given, domain division will be deactivated.
domainDivisions = 2 2 1

# If true, the current run will be stored, when SIGINT or SIGTERM is received. It means that all specified output files
# will be produced. The run can be continued later using the standard --continue option. If false, the run will be
# permanently lost.
saveOnSignal = true


########## RUNS AND RUN SPECIFIC PARAMETERS ##########

# In this exemplary input file there are three integration runs with names: "gas", "liquid" and "solid". Example overlap
# reduction run is in another sample input file - "overlap_reduction.ini". Each run has a set of its own parameters such
# as temperature, pressure, observables to be calculated, etc. The integration starts with thermalization phase in which
# the system should reach its equilibrium state. After that, the averaging phase follows, when ensemble averages of the
# observables are computed. During averaging phase the auto-adjustment of molecule an volume move amplitudes is turned
# off. After the finished run ensemble averages of observables are printed on the standard output.
# Moreover one can request to output the following auxiliary data:
# 1. internal RAMSNAP representation of the final snapshot (it is recommended to always generate it - simulation can
#    be continued after termination using the saved state)
# 2. Wolfram Mathematica notebook with the visualisation of the final snapshot
# 3. extended XYZ snapshot of the final state
# 4. internal compact RAMTRJ trajectory of the simulation
# 5. extended XYZ trajectory of the simulation
# 6. output file with ensemble averages (the same ones as are printed on the standard output by default)
# 7. instantaneous values of the observables every N cycles
# 8. ensemble averaged "bulk observables" in separate files (such as histograms)
# The observables to compute are specified using "observables" parameter.

# Each integration run is an INI section with the format "\[integration.[run name]\]" - "[run name]" is user-specified
# unique name of the run
[integration.gas]

# Temperature is inherited from the general section (see the information about inheritable paremeters near the top of
# the file). So are move types and scaling type. For the description of those parameters please refer to the general
# section.

# Pressure is specified explicitly. For the description, refer to the general section
pressure = 0.1

# For how many full MC cycles the thermalization should be performed
thermalisationCycles = 10000

# For how many full MC cycles averaging should be performed
averagingCycles = 20000

# Ensemble averages are taken "[averagingEvery]" cycles
averagingEvery = 200

# How often instantaneous values of observables should be sampled
snapshotEvery = 100

# The name of the file to save internal RAMSNAP representation of the packing. If empty, it is not generated. The
# internal representation encodes box size, particle positions and orientations, last Monte Carlo step amplitudes, the
# number of cycles and other internal information enabling the software to start the simulation in the same state as it
# was finished. The format is human-readable and can be manually parsed, however its specification may change over time.
packingFilename = packing_gas.ramsnap

# The name of the file to save extended XYZ snapshot of the packing. If empty, it is not generated. It encodes
# simulation box and both particle positions and orientation, as well the same auxiliary information as internal RAMSNAP
# format. The format is recognized by OVITO software. It may be supplemented by Wavefront OBJ shape model for
# visualization (see ./rampack shape-preview --help)
xyzPackingFilename = packing_gas.xyz

# If specified, the visualization of the final shapshot in the format of Wolfram Mathematica notebook will be stored to
# a file. Format:
# "[file name] ([format = standard])"
# "[file name]" is the name of the file where the visualization will be stored. "[format]" specifies how it will be
# stored. Available formats:
# 1. "standard"
#    A standard style - each shape is printed separately. The output is Graphics3D with a list of shapes, which is easy
#    to process but may grow large. It is advised for shapes with a small footprint.
# 2. "affineTransform"
#    A single shape with the default position and orientation is printed and then, for each shape in the packing it is
#    copied and appropriate affine transformation is applied to it. The output is Graphics3D with a list of positions
#    and orientations which is mapped over a single shape using AffineTransform. Is is advised for shapes with a large
#    footprint and for easy access to positions and orientations of the shapes.
# If left empty, creating Wolfram Mathematica visualization is omitted.
wolframFilename = packing_gas.nb

# The name of output file to store ensemble-averaged observables in SSV format (space separated values). If empty, no
# file is generated. The first two columns are the temperature and pressure, while the next ones are mean values and
# standard errors of observables, whose computation is requested in  "observables" parameter. Names of columns are
# printed in the first row (the header). If the file already exists, the old one is not erased, but instead new rows are
# appended to the old one.
outputFilename = out.txt

# The name of file to output snapshot observable values every "snapshotEvery" cycles in SSV format (space separated
# values). Parameter names are printed in the first row (the header). First column is cycle number, next ones are values
# of observables.
observableSnapshotFilename = observable_gas.txt

# Pattern used to create file names for bulk observables (see below). Each "{}" is replaced with a name of the
# observable. If "{}" is not found, "_{}.txt" is appended at the end and replacing process is redone.
bulkObservableFilenamePattern = {}_gas.txt

# If not empty, trajectories of the particles will be stored in a compact binary RAMTRJ format. It then can be replayed
# for example to calculate different observables. Not all cycles are stored - it is done every "snapshotEvery" cycles.
#
# Trajectories are stored in real time and are safely closed when the exception is thrown. If however it gets somehow
# truncated, it can be fixed using "./rampack trajectory --auto-fix". For more information see
# "./rampack trajectory --help".
recordingFilename = recording_gas.ramtrj

# If not empty, trajectories of the particles will be stored in a textual extended XYZ format, encoding box dimensions
# and both positions and orientations, as well as current number of cycles. The format is recognized by OVITO. It may be
# supplemented by Wavefront OBJ shape model for visualization (see ./rampack shape-preview --help)
xyzRecordingFilename = recording_gas.xyz

# The observables which should be computed during simulation. Each observables is in the format
# "([scope]) [observable name] ([observable-dependent parameters])"
#
# "[scope]" defines for which output type an observable should be computed. It can be one of:
# 1. "inline"
#    the observable is computed and printed on the standard output every 100 cycles. It may be useful for monitoring
#    the run in real time
# 2. "snapshot"
#    the observable is computed for every snapshot recorded in snapshot output file (see "observableSnapshotFilename"
#    parameter)
# 3. "averaging"
#    the observable is ensemble-averaged during averaging phase, printed on the standard output after the finished run
#    and to "outputFilename" output file (if specified)
# Scopes can be combined using "/" (without whitespace). For example "inline/snapshot numberDensity" will display number
# density on the standard output and include it in each row of the snapshot file, but ensemble value will not be
# computed. "[scope]" can be left empty - then is defaults to all three "inline/snapshot/averaging".
#
# Each observable consists of one or more interval and/or nominal values and they are printed separately in all of
# output scopes. Interval values are the ones that can be ensemble averaged, for example packing fraction, nematic order
# parameter etc. They are included in all requested scopes. Nominal values cannot be ensemble averaged, for example
# smectic parameter wavevector (it is a vector of integer values). They are included in inline and snapshot scope, but
# not in averaging.
#
# "[observable name]" is the name of the observable to be computed. Some observables have additional parameters
# "[observable-dependent parameters]" which follow right after the observable name. The full list of available
# observables is presented below. For each observable, its constituent values with their symbols are specified as
# sublist entries "x.y.". The type (interval/nominal) of values is also enlisted. Some observables have only one value,
# some have more.
# 1. "numberDensity"
#    number density of particles - the number of particles divided by the box volume. Constituent values:
#    1.1. "rho"
#         the number density; INTERVAL VALUE
# 2. "boxDimensions"
#    the dimensions of the simulation box. Constituent values:
#    2.1. "L_X"
#         x dimension of the box; INTERVAL VALUE
#    2.2. "L_Y"
#         y dimension of the box; INTERVAL VALUE
#    2.3. "L_Z"
#         z dimension of the box; INTERVAL VALUE
# 3. "packingFraction"
#    dimensionless packing fraction - the total volume occupied by particles divided by the box volume. Constituent
#    values:
#    3.1. "rho"
#         packing fraction; INTERVAL VALUE
# 4. "compressibilityFactor"
#    compressibility factor of the system, defined as (p*V)/(N*T). For ideal gas it is equal 1, for degenerate gases
#    it is bigger. Constituent values:
#    4.1. "Z"
#         compressibility factor; INTERVAL VALUE
# 5. "energyPerParticle"
#    interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent values:
#    5.1. "E"
#         potential energy per particle; INTERVAL VALUE
# 6. "energyFluctuationsPerParticle"
#    variance of interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent
#    values:
#    6.1. "varE"
#         variance of potential energy per particle; INTERVAL VALUE
# 7. "nematicOrder (dumpQTensor)"
#    P2 nematic order parameter computed as the highest magnitude eigenvalue of the nematic Q tensor. Main molecular
#    axes are shape-specific. Constituent values:
#    7.1. "P2"
#         nematic P2 parameter; INTERVAL VALUE
#    7.2. "Q_11"
#         (only if "dumpQTensor" specified) matrix element (1, 1) of Q-tensor; INTERVAL VALUE
#    7.3. "Q_12"
#         (only if "dumpQTensor" specified) matrix element (1, 2) of Q-tensor; INTERVAL VALUE
#    7.4. "Q_13"
#         (only if "dumpQTensor" specified) matrix element (1, 3) of Q-tensor; INTERVAL VALUE
#    7.5. "Q_22"
#         (only if "dumpQTensor" specified) matrix element (2, 2) of Q-tensor; INTERVAL VALUE
#    7.6. "Q_23"
#         (only if "dumpQTensor" specified) matrix element (2, 3) of Q-tensor; INTERVAL VALUE
#    7.7. "Q_33"
#         (only if "dumpQTensor" specified) matrix element (3, 3) of Q-tensor; INTERVAL VALUE
# 8. OLD SYNTAX
#    "smecticOrder ([n_x max] [n_y max] [n_z max]) (dumpTauVector)"
#    NEW SYNTAX
#    "smecticOrder (max_n {[n_x=n_y=n_z] | [n_x max] [n_x max] [n_x max]}) (dumpTauVector) (focalPoint [point name])"
#    absolute value of smectic tau parameter (not normalized by number density - (num of particles)/volume means maximal
#    smectic order). The tau value depends on the wavevector of smectic order parameter. Here, the one giving the
#    highest value of taus is selected from all PBC-compatible alternatives given by:
#    k = sum_alpha (n_alpha * g_alpha),
#    where g_alpha (alpha = x, y, z) are reciprocal lattice vectors (which the box being the unit cell), while n_alpha
#    are Miller indices taken from [-"[n_alpha max]", "[n_alpha max]"] - the maximal length of the wavevector is
#    controlled by an optional parameter "[n_alpha max]". If it is not specified, it defaults to 5. New syntax lets user
#    choose which point should be used to calculate smectic order. If not specified, it defaults to the geometric origin
#    "o".
#    Constituent values:
#    8.1. "tau"
#         absolute value of smectic order parameter; INTERVAL VALUE
#    8.2. "k_x"
#         (only if "dumpTauVector" specified) x coordinate of the wavevector of smectic order parameter; INTERVAL VALUE
#    8.3. "k_y"
#         (only if "dumpTauVector" specified) x coordinate of the wavevector of smectic order parameter; INTERVAL VALUE
#    8.4. "k_z"
#         (only if "dumpTauVector" specified) x coordinate of the wavevector of smectic order parameter; INTERVAL VALUE
#    8.5. "n_tau"
#         Miller indices of smectic order parameter in the format "[n_x].[n_y].[n_z]"; NOMINAL VALUE
# 9. OLD SYNTAX
#    "bondOrder [Miller indices] [rank 1] [rank 2] ..."
#    NEW SYNTAX
#    "bondOrder millerIdx [nx].[ny].[nz] ranks [rank 1] [rank 2] ... (layeringPoint [layering point name]) \
#     (bondOrderPoint [bond order point name])"
#    bond order parameter of a given rank "r" is computed by finding "r" nearest neighbours of a molecule, projecting
#    the vectors joining the molecule with neighbours onto the plane given by "[Miller indices]" with respect to the
#    simulation box, computing angles phi_j (j is the index of a neighbour) between the projections and an arbitrary
#    direction on this plane an then calculating
#    psi_r = 1/r sum_j exp(i r phi_j).
#    Nearest neighbours are also calculated using a projection onto a nearest smectic layer defined by
#    "[Miller indices]" (layer association is done using complex phase of the smectic parameter). Finally, the absolute
#    value of psi_r is averaged over all molecules in the system. "[Miller indices]" should be in format "[h].[k].[l]"
#    (negative values are allowed). At least one rank should be given. New syntax enables user to change which point
#    is used to assign molecules into layers ("[layering point name]") and which is used to find nearest neighbours and
#    calculate bond order ("[bond order point name]"). Both default to the geometric origin "o".
#    Constituent values:
#    9.x. "psi[rank]"
#         bond order parameter of rank "[rank]". There are as many of them as specified; INTERVAL VALUE
# 10. "rotationMatrixDrift"
#     squared Frobenius norm of the expression M M^T - 1, where M is an orientation of a given molecule. This observable
#     is useful to track the drift of orientation matrix errors cumulating during the simulation. Constituent values:
#     10.1. "F^2"
#           mean squared Frobenius norm, averages over all molecules in a snapshot; INTERVAL VALUE
#     10.2. "min(F^2)"
#           minimal squared Frobenius norm in a snapshot; INTERVAL VALUE
#     10.3. "max(F^2)"
#           maximal squared Frobenius norm in a snapshot; INTERVAL VALUE
# 11. "temperature"
#     current temperature of the system. Constituent values:
#     11.1. "T"
#           the temperature; INTERVAL VALUE
# 12. "pressure"
#     current pressure of the system. Constituent values:
#     12.1. "p"
#          the pressure; INTERVAL VALUE
# 13. "fourierTracker [wavenumber x] [... y] [... z] [function]"
#     Goldstone tracker observable which tracks the movement of the system. The tracking is done by finding the maximum
#     of
#         F(x, y, z) = [function] * rho(x, y, z),
#     where rho(x, y, z) is local density, however the above expression is restricted only to Fourier components
#     described by n_x = "[wavenumber x]", n_y = "[... y]", n_z "[... z]". More precisely, given Fourier expansion of F:
#         F(x, y, z) = sum_{n_x,n_y,n_z = 0}^{inf} prod_{i in {x,y,z}} (A_i cos(2pi n_i i) + Bi sin(2pi n_i i)),
#     only the terms with n_x = "[wavenumber x]", n_y = "[... y]", n_z = "[... z]" are left. Please notice that x, y, z
#     are relative coordinates to facilitate calculation in the triclinic simulation box. As the terms are oscillating,
#     there are many global maxima - the one which is closest to the previously registered maximum is selected (for the
#     first measurement, the maximum closest to (x, y, z) = (0, 0, 0) is chosen). One or two of "[wavenumber ...]" can
#     be 0 - it then reduces the tracking to, respectively, 2D and 1D.
#     [function] is some function taking shape at a given position and returning some value. It can be one of:
#     13.1.1. "const"
#             constant function. F(x, y, z) reduces then to rho(x, y, z), so it can be used to track density modulation
#     13.1.2. "(primaryAxis|secondaryAxis|auxiliaryAxis) (x|y|z)"
#             if returns x|y|z component of primaryAxis|secondaryAxis|auxiliaryAxis of the shape, so it can be used to
#             track modulation of shape axis
#     One can think of this observable as the generalization of finding the phase of smectic order parameter. In fact,
#     if only one of "[wavenumber ...]" is non-zero and "[function]" = "const", it reduces to calculating the position
#     of the maximum of smectic density modulation.
#     Constituent values (as in all Goldstone tracker observables):
#     13.2.1. "[function signature]_fourier_tracker_x"
#     13.2.2. "[function signature]_fourier_tracker_y"
#     13.2.3. "[function signature]_fourier_tracker_z"
#             position of the drifting maximum of oscillations
#     13.2.4. "[function signature]_fourier_tracker_ox"
#     13.2.5. "[function signature]_fourier_tracker_oy"
#     13.2.6. "[function signature]_fourier_tracker_oz"
#             Euler angles of system orientation drift. It is not tracker by the "fourierTracker", so they are always 0
#     "[function signature]" is some shorthand notation of the selected "[function]" variant.
observables = numberDensity , inline packingFraction , compressibilityFactor

# Observables with many values (for example whole plots), which are too large to be normal observables. They can however
# be averaged over many system snapshots. Averaging of them is done in the averaging phase of the simulation, every
# "averagingEvery" cycles. At the end, the result is dumped into a dedicated file given by
# "bulkObservableFilenamePattern" (supplemented with the observable's name in place of "{}"). One may specify more than
# one bulk observable separating them using comma ",". Available bulk observables:
# 1. "pairDensityCorrelation [max distance] [num bins] [binning specification]"
#    Pair density correlation vs distance (a ratio of the actual number of molecules in the packing with a given
#    distance to the expected number of molecules assuming the packing is homogeneous). In that way:
#    * rho(r) = 1  => no correlation at distance r
#    * rho(r) < 1  => negative correlation at distance r
#    * rho(r) > 1  => positive correlation at distance r
#    Observable is sampled for distances in the range [0, "[max distance]"]. "[binning specification]" describes which
#    pairs are selected and how the distance is calculated. Variants:
#    1.1. "radial ([focal point])
#         All pairs are sampled and the distance is just an ordinary Euclidean distance. Produces a standard radial
#         distribution function. "[focal point]" describes which named point should be used and defaults to the
#         geometric origin "o". "[binning signature name]" := "r".
#    1.2. "layerwiseRadial [h].[k].[l] ([focal point])"
#         First, the system if divided into layers, calculated based on the smectic order parameter for Miller indices
#         "[h]", "[k]", "[l]". Then, pairs are selected only from within the layer (subject to PBC) and distance is
#         computed along the layer plane. "[focal point]" describes which named point should be used and defaults to
#         the geometric origin "o". "[binning signature name]" := "lr"
#    The observable outputs rows of the form:
#        r rho(r)
#    Observable name is "rho_[binning signature name]", where "[binning signature name]" depends on
#    "[binning specification]".
# 2. "pairAveragedCorrelation [max distance] [num bins] [correlation function] [binning specification]"
#    Average value of correlation function vs the distance between molecules. "[max distance]", "[num bins]" and
#    "[binning specification]" have exactly the same meaning as in 1. "pairDensityCorrelation". "[correlation function]"
#    specifies which correlation function should be calculated. Available variants:
#    2.1. "S110 [axis]"
#         S_110 correlation function, defined as the dot product of the axes of molecules. "[axis]" can be "primary",
#         "secondary" or "auxiliary" and specifies which molecular axis should be used.
#         "[function signature name]" := "S110"
#    The observable outputs rows of the form:
#        r corr(r)
#    Observable name is "[function signature name]_[binning signature name]", where "[function signature name]" depends
#    on the chosen function and "[binning signature name]" on binning specification.
# 3. "densityHistogram n_bins [number of bins x] [... y] [... z] (tracker [tracker name and arguments])"
#    calculates the density histogram of the system with number of bins in each direction specified by
#    "[number of bins ...]". Number of bins equal 0 or 1 turns off binning in one direction. Bins are normalized in
#    such a way that for a perfectly homogeneous system, regardless of the number of bins, each bin value would be 1.
#    The system movement may be tracked and cancelled out using "tracker ...". "[tracker name and arguments]" can be
#    any of Goldstone tracker observables (see "observables" field documention), for example "fourierTracker". The
#    observable outputs each bin as a single row in the form:
#        bin_middle_x ..._y ..._z bin_value
#    where bin_middle_... represent the position of the middle of a given bin in [0, 1) relative coordinates. If binning
#    in a given direction is turned off, its corresponding coordinate will be always equal 0.5.
#    Observable name is "rho_xyz".
bulkObservables = pairDensityCorrelation 5 100 radial

# This is the end of parameters for "gas" run. Next ones are for subsequent "liquid" and "solid" runs. They have
# identical meaning, so the descriptions are not repeated.

[integration.liquid]
# Temperature, move types and scaling type inherited from the previous run
pressure = 11.5
thermalisationCycles = 250000
averagingCycles = 200000
averagingEvery = 2000
snapshotEvery = 100
packingFilename = packing_liquid.ramsnap
xyzPackingFilename = packing_liquid.xyz
wolframFilename = packing_liquid.nb
outputFilename = out.txt
observableSnapshotFilename = observable_liquid.txt
bulkObservableFilenamePattern = {}_liquid.txt
recordingFilename = recording_liquid.ramtrj
xyzRecordingFilename = recording_liquid.xyz
observables = numberDensity , inline packingFraction , compressibilityFactor
bulkObservables = pairDensityCorrelation 5 100 radial

[integration.solid]
# Temperature and move types and scaling type inherited from the previous run. We change the pressure and scaling type
# to triclinic to facilitate relaxation of the crystalline structure
pressure = 20
scalingType = delta triclinic
volumeStepSize = 0.001
thermalisationCycles = 1000000
averagingCycles = 2000000
averagingEvery = 20000
snapshotEvery = 100
packingFilename = packing_solid.ramsnap
xyzPackingFilename = packing_solid.xyz
wolframFilename = packing_solid.nb
outputFilename = out.txt
observableSnapshotFilename = observable_solid.txt
bulkObservableFilenamePattern = {}_solid.txt
recordingFilename = recording_solid.ramtrj
xyzRecordingFilename = recording_solid.xyz
observables = numberDensity , inline packingFraction , compressibilityFactor
bulkObservables = pairDensityCorrelation 5 100 radial